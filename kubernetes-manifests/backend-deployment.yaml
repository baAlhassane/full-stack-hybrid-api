# Définition du Deployment pour le backend Spring Boot
# Un Deployment gère la création et la mise à jour des Pods (instances de votre application).
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hybrid-api-backend-deployment # Nom unique pour ce déploiement
  labels:
    app: hybrid-api-backend # Labels pour identifier ce déploiement et ses pods associés
spec:
  replicas: 1 # Nombre d'instances (pods) de l'application à exécuter. Pour l'apprentissage, 1 est suffisant.
  selector:
    matchLabels:
      app: hybrid-api-backend # Sélectionne les pods avec ce label pour que le déploiement les gère
  template: # Modèle pour les pods qui seront créés par ce déploiement
    metadata:
      labels:
        app: hybrid-api-backend # Labels des pods
    spec:
      containers:
        - name: hybrid-api-backend # Nom du conteneur dans le pod
          image: alhas2186/hybrid-api-backend:1.0.0 # L'image Docker que nous avons poussée (CORRIGÉ)
          ports:
            - containerPort: 8081 # Le port sur lequel l'application Spring Boot écoute DANS le conteneur
          # Ressources (optionnel, mais bonne pratique pour la gestion des ressources du cluster)
          resources:
            requests: # Requêtes minimales de ressources (Kubernetes essaiera de garantir ces ressources)
              memory: "512Mi"
              cpu: "500m" # 0.5 CPU
            limits: # Limites maximales de ressources (le conteneur ne dépassera pas ces limites)
              memory: "1024Mi"
              cpu: "1000m" # 1 CPU
          # Vérification de l'état de santé de l'application (Liveness et Readiness Probes)
          # Kubernetes utilisera ces probes pour savoir si le conteneur est en vie et prêt à recevoir du trafic
          livenessProbe: # Vérifie si l'application est toujours en cours d'exécution (si elle plante, Kubernetes la redémarre)
            httpGet:
              path: /actuator/health # L'endpoint de santé de Spring Boot
              port: 8081
            initialDelaySeconds: 30 # Attendre 30 secondes avant la première vérification
            periodSeconds: 10 # Vérifier toutes les 10 secondes
            failureThreshold: 3 # Nombre d'échecs consécutifs avant de considérer le pod comme non sain
          readinessProbe: # Vérifie si l'application est prête à recevoir du trafic (si elle est prête, le trafic lui est envoyé)
            httpGet:
              path: /actuator/health
              port: 8081
            initialDelaySeconds: 20 # Attendre 20 secondes avant la première vérification
            periodSeconds: 5 # Vérifier toutes les 5 secondes
            failureThreshold: 3

---
# Définition du Service pour le backend Spring Boot
# Un Service expose votre application à l'intérieur du cluster ou à d'autres services.
apiVersion: v1
kind: Service
metadata:
  name: hybrid-api-backend-service # Nom du service (sera utilisé pour la découverte de service)
spec:
  selector:
    app: hybrid-api-backend # Sélectionne les pods du déploiement ci-dessus (basé sur leurs labels)
  ports:
    - protocol: TCP
      port: 8081 # Le port du service (accessible à l'intérieur du cluster par d'autres pods)
      targetPort: 8081 # Le port du conteneur vers lequel le trafic est redirigé
  type: ClusterIP # Type de service:
                  # ClusterIP: Accessible uniquement à l'intérieur du cluster (par défaut et recommandé pour les backends)
                  # NodePort: Expose le service sur un port de chaque nœud du cluster (accessible depuis l'extérieur)
                  # LoadBalancer: Crée un load balancer externe (pour les fournisseurs de cloud comme AWS, GCP, Azure)
                  # ExternalName: Mappe le service à un nom DNS externe
